SZCZEGÓŁOWA DOKUMENTACJA TECHNICZNA APLIKACJI MINI-TWITTER
================================================================

SPIS TREŚCI:
1. Wprowadzenie
2. Architektura Systemu
3. Frontend
4. Backend
5. Baza Danych
6. Bezpieczeństwo
7. Funkcjonalności
8. Optymalizacja
9. Wdrożenie
10. Rozwój

1. WPROWADZENIE
===============
1.1. Cel Projektu
-----------------
Mini-Twitter to nowoczesna aplikacja społecznościowa wzorowana na Twitterze, stworzona z wykorzystaniem najnowszych technologii webowych. Główne cele projektu:

a) Funkcjonalne:
   - Umożliwienie użytkownikom dzielenia się krótkimi wiadomościami (tweetami)
   - Zapewnienie interakcji społecznościowych (polubienia, komentarze, obserwowanie)
   - Implementacja systemu powiadomień w czasie rzeczywistym
   - Zarządzanie profilem użytkownika

b) Techniczne:
   - Wykorzystanie architektury serverless
   - Zapewnienie wysokiej wydajności i skalowalności
   - Implementacja bezpiecznej autentykacji i autoryzacji
   - Optymalizacja pod kątem SEO i wydajności

1.2. Użyte Technologie
----------------------
Stack technologiczny został starannie dobrany pod kątem wydajności, skalowalności i łatwości rozwoju:

Frontend:
- Next.js 14 (App Router) - framework React do renderowania po stronie serwera
- TypeScript - typowany JavaScript zwiększający bezpieczeństwo kodu
- Tailwind CSS - utility-first framework CSS
- React Hook Form - zarządzanie formularzami
- Zod - walidacja danych
- Shadcn/ui - komponenty UI

Backend:
- Next.js API Routes - endpoints REST
- Prisma - ORM do komunikacji z bazą danych
- MySQL - relacyjna baza danych
- Clerk - system autentykacji
- Server Actions - bezpośrednia komunikacja z bazą danych

2. ARCHITEKTURA SYSTEMU
=======================
2.1. Ogólny Zarys Architektury
------------------------------
Aplikacja wykorzystuje architekturę monolityczną z elementami mikroserwisów:

a) Warstwy aplikacji:
   - Warstwa prezentacji (Frontend)
   - Warstwa logiki biznesowej (Backend)
   - Warstwa danych (Baza danych)

b) Komunikacja między warstwami:
   - API Routes dla operacji CRUD
   - Server Actions dla bezpośrednich mutacji
   - Server Components dla renderowania SSR

2.2. Przepływ Danych
--------------------
Szczegółowy opis przepływu danych w aplikacji:

1. Żądanie użytkownika:
   - Klient wysyła żądanie do serwera Next.js
   - Server Components przechwytują żądanie
   - Następuje weryfikacja autentykacji przez Clerk

2. Przetwarzanie żądania:
   - Logika biznesowa w Server Actions
   - Komunikacja z bazą danych przez Prisma
   - Przygotowanie odpowiedzi

3. Odpowiedź:
   - Renderowanie komponentów po stronie serwera
   - Hydratacja danych na kliencie
   - Aktualizacja interfejsu użytkownika

3. FRONTEND
===========
3.1. Struktura Projektu
-----------------------
Organizacja kodu frontendowego:

```
src/
├── app/                    # Routing i strony
│   ├── (auth)/            # Strony autoryzacji
│   ├── (home)/            # Główne strony aplikacji
│   └── api/               # Endpointy API
├── components/            # Komponenty React
│   ├── cards/            # Komponenty kart (tweety, użytkownicy)
│   ├── forms/            # Formularze
│   ├── sharing/          # Komponenty współdzielone
│   └── ui/               # Podstawowe komponenty UI
├── hooks/                # Custom hooks
├── lib/                  # Funkcje pomocnicze
└── validations/         # Schematy walidacji
```

3.2. Komponenty
--------------
Szczegółowy opis głównych komponentów:

a) Komponenty Tweetów:
   - CreateTweetForm - tworzenie nowych tweetów
   - TweetCard - wyświetlanie pojedynczego tweeta
   - TweetList - lista tweetów z infinite scroll
   - TweetActions - przyciski akcji (like, bookmark, reply)

b) Komponenty Użytkownika:
   - UserProfile - profil użytkownika
   - EditProfileForm - edycja profilu
   - FollowButton - obserwowanie użytkowników
   - UserList - lista użytkowników

c) Komponenty UI:
   - Button - przyciski z różnymi wariantami
   - Input - pola wprowadzania
   - Modal - okna modalne
   - Toast - powiadomienia

3.3. Routing
-----------
System routingu oparty na Next.js App Router:

```
/                   # Strona główna
├── sign-in         # Logowanie
├── sign-up         # Rejestracja
├── onboarding      # Konfiguracja profilu
├── home            # Strumień tweetów
├── explore         # Eksploracja
├── bookmarks       # Zakładki
├── notifications   # Powiadomienia
└── [username]      # Profile użytkowników
    ├── status      # Pojedynczy tweet
    ├── followers   # Obserwujący
    └── following   # Obserwowani
```

4. BACKEND
==========
4.1. Server Actions
------------------
Implementacja głównych akcji serwerowych:

a) Zarządzanie Użytkownikami:
```typescript
// Przykład akcji tworzenia użytkownika
export async function saveUserAction({
  id,
  name,
  username,
  email,
  imageUrl,
  bio,
  isCompleted
}: SaveUserActionProps): Promise<SaveUserActionType> {
  try {
    // Walidacja danych
    if (!id || !name) throw new Error("Brak wymaganych danych");

    // Sprawdzenie istniejącego użytkownika
    const existingUser = await prisma.user.findUnique({
      where: { id }
    });

    // Aktualizacja lub utworzenie użytkownika
    if (existingUser) {
      return await prisma.user.update({
        where: { id },
        data: { name, bio, isCompleted }
      });
    }

    // Utworzenie nowego użytkownika
    return await prisma.user.create({
      data: {
        id,
        imageUrl,
        name,
        username,
        email,
        bio,
        isCompleted
      }
    });
  } catch (error) {
    console.error("[ERROR_SAVE_USER_ACTION]", error);
    throw error;
  }
}
```

b) Zarządzanie Tweetami:
```typescript
// Przykład akcji tworzenia tweeta
export async function createTweetAction({
  userId,
  text,
  imageUrl,
  parentId
}: CreateTweetActionProps): Promise<CreateTweetActionType> {
  try {
    // Utworzenie tweeta
    const tweet = await prisma.thread.create({
      data: {
        userId,
        text,
        imageUrl,
        parentId
      }
    });

    // Obsługa powiadomień
    if (parentId) {
      await createNotification({
        userId: tweet.userId,
        type: "reply",
        sourceId: parentId
      });
    }

    return tweet;
  } catch (error) {
    console.error("[ERROR_CREATE_TWEET_ACTION]", error);
    throw error;
  }
}
```

4.2. API Routes
--------------
Endpointy REST API:

a) Struktura endpointów:
```
/api/
├── auth/           # Endpointy autoryzacji
├── users/          # Zarządzanie użytkownikami
├── tweets/         # Operacje na tweetach
├── notifications/  # System powiadomień
└── search/         # Wyszukiwarka
```

b) Przykład implementacji endpointu:
```typescript
// api/tweets/route.ts
export async function GET(req: Request) {
  try {
    const { searchParams } = new URL(req.url);
    const page = parseInt(searchParams.get("page") || "1");
    const limit = parseInt(searchParams.get("limit") || "10");

    const tweets = await prisma.thread.findMany({
      take: limit,
      skip: (page - 1) * limit,
      include: {
        user: true,
        likes: true,
        replies: true
      },
      orderBy: {
        createdAt: "desc"
      }
    });

    return NextResponse.json(tweets);
  } catch (error) {
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 }
    );
  }
}
```

5. BAZA DANYCH
==============
5.1. Schema Prisma
-----------------
Szczegółowy opis modeli danych:

```prisma
// Schema.prisma
model User {
  id          String    @id
  name        String    @db.Char(30)
  username    String    @unique @db.Char(64)
  email       String    @unique
  imageUrl    String
  bannerUrl   String?
  location    String?   @db.Char(30)
  website     String?   @db.Char(100)
  isCompleted Boolean   @default(false)
  bio         String?   @db.Char(255)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relacje
  tweets        Thread[]
  likes         Like[]
  bookmarks     Bookmark[]
  notifications Notification[]
  followers     Follower[]     @relation("Following")
  following     Follower[]     @relation("Followers")

  @@index([username, name])
}

model Thread {
  id        String    @id @default(cuid())
  text      String    @db.VarChar(280)
  imageUrl  String?
  userId    String
  parentId  String?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  // Relacje
  user      User      @relation(fields: [userId], references: [id])
  parent    Thread?   @relation("Replies", fields: [parentId], references: [id])
  replies   Thread[]  @relation("Replies")
  likes     Like[]
  bookmarks Bookmark[]

  @@index([userId])
  @@index([parentId])
}

// ... pozostałe modele
```

5.2. Optymalizacja Bazy Danych
-----------------------------
Zastosowane techniki optymalizacji:

a) Indeksowanie:
   - Indeksy dla często wyszukiwanych pól
   - Złożone indeksy dla relacji
   - Indeksy dla sortowania

b) Normalizacja:
   - Prawidłowe relacje między tabelami
   - Unikanie redundancji danych
   - Zachowanie integralności referencyjnej

c) Zapytania:
   - Optymalizacja złączeń
   - Efektywne wykorzystanie indeksów
   - Cachowanie wyników

6. BEZPIECZEŃSTWO
================
6.1. Autentykacja
----------------
System autentykacji oparty na Clerk:

a) Proces rejestracji:
   1. Rejestracja przez Clerk
   2. Weryfikacja email
   3. Utworzenie profilu w bazie
   4. Proces onboardingu

b) Zabezpieczenia:
   - OAuth 2.0
   - JWT Tokens
   - Bezpieczne sesje
   - Szyfrowanie danych

6.2. Autoryzacja
---------------
System uprawnień i dostępu:

a) Middleware:
```typescript
// middleware.ts
import { authMiddleware } from "@clerk/nextjs";

export default authMiddleware({
  publicRoutes: ["/", "/api/public"],
  ignoredRoutes: ["/api/webhook"]
});

export const config = {
  matcher: ["/((?!.*\\..*|_next).*)", "/", "/(api|trpc)(.*)"],
};
```

b) Kontrola dostępu:
   - Sprawdzanie uprawnień użytkownika
   - Walidacja tokenów
   - Rate limiting

7. FUNKCJONALNOŚCI
=================
7.1. System Tweetów
------------------
Szczegółowy opis funkcjonalności tweetów:

a) Tworzenie:
   - Limit 280 znaków
   - Możliwość dodawania obrazów
   - Walidacja contentu
   - Obsługa hashtagów i wzmianek

b) Interakcje:
   - Polubienia
   - Odpowiedzi
   - Udostępnianie
   - Zakładki

7.2. System Społecznościowy
--------------------------
Funkcje społecznościowe:

a) Obserwowanie:
   - Follow/Unfollow
   - Lista obserwujących
   - Sugestie użytkowników

b) Powiadomienia:
   - Nowe polubienia
   - Nowe odpowiedzi
   - Nowi obserwujący
   - Status przeczytania

8. OPTYMALIZACJA
===============
8.1. Frontend
------------
Techniki optymalizacji frontendu:

a) Wydajność:
   - Code splitting
   - Lazy loading
   - Optymalizacja obrazów
   - Cachowanie komponentów

b) SEO:
   - Metadata
   - OpenGraph
   - Semantic HTML
   - Sitemap

8.2. Backend
-----------
Optymalizacja backendu:

a) Wydajność:
   - Cachowanie zapytań
   - Optymalizacja bazy danych
   - Kompresja odpowiedzi
   - Rate limiting

b) Skalowalność:
   - Horizontal scaling
   - Load balancing
   - Connection pooling
   - Query optimization

9. WDROŻENIE
============
9.1. Środowisko Produkcyjne
--------------------------
Konfiguracja środowiska:

a) Infrastruktura:
   - Vercel (hosting)
   - PlanetScale (baza danych)
   - Clerk (autentykacja)
   - Cloudinary (obrazy)

b) CI/CD:
   - Automatyczne deploye
   - Testy przed wdrożeniem
   - Monitoring błędów
   - Backup danych

10. ROZWÓJ
==========
10.1. Planowane Funkcjonalności
-----------------------------
Kierunki rozwoju aplikacji:

a) Nowe funkcje:
   - System wiadomości prywatnych
   - Zaawansowane statystyki
   - System monetyzacji
   - Integracje z zewnętrznymi API

b) Optymalizacje:
   - Zwiększenie wydajności
   - Poprawa UX
   - Rozbudowa testów
   - Monitoring i analityka

PODSUMOWANIE
============
Mini-Twitter to kompleksowa aplikacja społecznościowa, która łączy w sobie:
- Nowoczesną architekturę
- Zaawansowane funkcje społecznościowe
- Wysoką wydajność
- Bezpieczeństwo
- Skalowalność

Aplikacja jest gotowa do dalszego rozwoju i skalowania, z solidną podstawą techniczną i przemyślaną architekturą. 